# -*- coding: utf-8 -*-
"""SemaforosAutoOrganizables-SC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YNyg5TVh7IJDuTIjBXVnflSGOtVcmdpV
"""

#new
import random
import time
from collections import deque

# ---------------------------
# Par√°metros del sistema
# ---------------------------
SEED = 42
random.seed(SEED)

r = 1   # distancia m√≠nima antes del sem√°foro (bloque)
d = 4   # distancia m√°xima para detecci√≥n atr√°s del sem√°foro (bloques)
e = 2   # distancia corta m√°s all√° de la intersecci√≥n (bloques)
n = 4   # umbral de veh√≠culos a distancia d (para solicitar verde)
u = 6   # tiempo m√≠nimo en verde (tics)
YELLOW_TIME = 1  # tiempo del amarillo intermedio

IN_LENGTH = 6
OUT_LENGTH = 6
SPAWN_PROB = 0.3
MAX_TICKS = 50
SLEEP = 0.5

# ---------------------------
# Modelos
# ---------------------------

class TrafficLight:
    def __init__(self, name):
        self.name = name
        self.state = 'RED'
        self.time_in_state = 0
        self.requested = False
        self.min_green_remaining = 0
        self.next_state = None

    def set_state(self, new_state, next_state=None):
        prev = self.state
        self.state = new_state
        self.next_state = next_state
        self.time_in_state = 0

        # Colores para mejor visualizaci√≥n
        color_map = {'RED': 'üî¥', 'YELLOW': 'üü°', 'GREEN': 'üü¢'}
        print(f"    üö¶ Sem√°foro {self.name}: {color_map.get(prev, prev)} ‚Üí {color_map.get(new_state, new_state)}")

        if new_state == 'GREEN':
            self.min_green_remaining = u
            self.next_state = None
        elif new_state == 'YELLOW':
            if next_state is not None:
                self.next_state = next_state
            else:
                self.next_state = 'RED' if prev == 'GREEN' else 'GREEN'
            self.min_green_remaining = 0
        else:  # RED
            self.min_green_remaining = 0
            self.next_state = None

    def tick(self):
        self.time_in_state += 1
        if self.state == 'GREEN' and self.min_green_remaining > 0:
            self.min_green_remaining -= 1

    def get_display_state(self):
        colors = {'RED': 'üî¥', 'YELLOW': 'üü°', 'GREEN': 'üü¢'}
        return colors.get(self.state, self.state)

class Road:
    def __init__(self, name):
        self.name = name
        self.approach = deque([0]*IN_LENGTH)
        self.exit_lane = deque([0]*OUT_LENGTH)

    def spawn_vehicle(self, prob=SPAWN_PROB):
        if random.random() < prob:
            if self.approach[0] == 0:
                self.approach[0] = 1

    def count_behind_red(self, distance=d):
        start = max(0, IN_LENGTH - distance)
        return sum(self.approach[i] for i in range(start, IN_LENGTH))

    def vehicle_at_r(self):
        return self.approach[IN_LENGTH-r] == 1 if IN_LENGTH-r >= 0 else False

    def vehicles_in_intersection_zone(self):
        start = max(0, IN_LENGTH - r)
        return sum(self.approach[i] for i in range(start, IN_LENGTH))

    def vehicles_stopped_beyond_e(self):
        return sum(self.exit_lane[i] for i in range(min(e, len(self.exit_lane))))

    def move_vehicles_forward(self, can_enter_intersection):
        crossed = 0
        just_crossed = False

        # Mover veh√≠culos en exit_lane

        #quitamos el ultimo carrito
        if self.exit_lane[-1] == 1:
            self.exit_lane[-1] = 0


        for i in range(OUT_LENGTH-2, -1, -1):

            if self.exit_lane[i] == 1 :
                #if just_crossed and i == 0:
                    #continue  # no mover el reci√©n llegado
                self.exit_lane[i+1] = 1
                self.exit_lane[i] = 0

        # Veh√≠culo en la l√≠nea de parada
        if self.approach[IN_LENGTH-1] == 1:
            if can_enter_intersection:
                if self.exit_lane[0] == 0:
                    self.exit_lane[0] = 1
                    self.approach[IN_LENGTH-1] = 0
                    crossed = 1
                    just_crossed = True  # marcar que reci√©n cruz√≥

        # Mover veh√≠culos en approach
        for i in range(IN_LENGTH-2, -1, -1):
            if self.approach[i] == 1 and self.approach[i+1] == 0:
                self.approach[i+1] = 1
                self.approach[i] = 0



        return crossed

    def get_visual_representation(self, extra_before=6):
        """Representaci√≥n visual extendida de la carretera"""
        start_index = max(0, IN_LENGTH - max(d, extra_before))

        # Zona previa antes de detecci√≥n
        before_zone = ''.join('üöó' if self.approach[i] else '¬∑'
                              for i in range(start_index, IN_LENGTH - d))

        # Zona de detecci√≥n
        detection_zone = ''.join('üöó' if self.approach[i] else '¬∑'
                                 for i in range(max(0, IN_LENGTH-d), IN_LENGTH-r))

        # Zona cr√≠tica
        critical_zone = ''.join('üöô' if self.approach[i] else '¬∑'
                                for i in range(max(0, IN_LENGTH-r), IN_LENGTH))

        # Zona de salida
        exit_zone = ''.join('üöê' if self.exit_lane[i]==1 else '¬∑'
                            for i in range(min(e, OUT_LENGTH)))
                            #for i in range((OUT_LENGTH)-(OUT_LENGTH-e)))



        # Resto de la salida
        rest_exit = ''.join('üöó' if self.exit_lane[i] else '¬∑'
                            for i in range(min(e, OUT_LENGTH), OUT_LENGTH))

        return f"{before_zone}{detection_zone}[{critical_zone}]üö¶{exit_zone}|{rest_exit}"

# ---------------------------
# Simulaci√≥n principal
# ---------------------------

class Simulation:
    def __init__(self):
        self.lightA = TrafficLight('A')
        self.lightB = TrafficLight('B')
        self.lightA.set_state('RED')
        self.lightB.set_state('RED')
        self.roadA = Road('A')
        self.roadB = Road('B')
        self.t = 0
        self.priority = None
        self.last_was = None
        self.log = []

    def print_header(self):
        print("=" * 80)
        print("üö¶ SIMULADOR DE SEM√ÅFOROS AUTO-ORGANIZANTES üö¶")
        print("=" * 80)
        print(f"üìä Par√°metros: r={r}, d={d}, e={e}, n={n}, u={u}")
        print(f"üöó Leyenda: üöó=veh√≠culo normal, üöô=zona cr√≠tica, üöê=zona de salida")
        print("=" * 80)

    def display_state(self):
        print(f"\n‚è∞ TICK {self.t:03d}")
        print("-" * 60)

        print(f"üö¶ Sem√°foro A: {self.lightA.get_display_state()} (t:{self.lightA.time_in_state}, minG:{self.lightA.min_green_remaining})")
        print(f"üö¶ Sem√°foro B: {self.lightB.get_display_state()} (t:{self.lightB.time_in_state}, minG:{self.lightB.min_green_remaining})")

        print(f"üõ£Ô∏è  Carretera A: {self.roadA.get_visual_representation()}")
        print(f"üõ£Ô∏è  Carretera B: {self.roadB.get_visual_representation()}")

        cA = self.roadA.count_behind_red()
        cB = self.roadB.count_behind_red()
        critA = self.roadA.vehicles_in_intersection_zone()
        critB = self.roadB.vehicles_in_intersection_zone()
        congA = self.roadA.vehicles_stopped_beyond_e()
        congB = self.roadB.vehicles_stopped_beyond_e()

        print(f"üìä An√°lisis:")
        print(f"   ‚Ä¢ Veh√≠culos esperando (d={d}): A={cA}, B={cB}")
        print(f"   ‚Ä¢ En zona cr√≠tica (r={r}): A={critA}, B={critB}")
        print(f"   ‚Ä¢ Congesti√≥n salida (e={e}): A={congA}, B={congB}")
        print(f"   ‚Ä¢ Solicitudes activas: A={'‚úÖ' if self.lightA.requested else '‚ùå'}, B={'‚úÖ' if self.lightB.requested else '‚ùå'}")

    def evaluate_requests(self):
        cA = self.roadA.count_behind_red()
        cB = self.roadB.count_behind_red()
        self.lightA.requested = (cA >= n)
        self.lightB.requested = (cB >= n)
        return cA, cB

    def apply_rules_and_transition(self):
        A = self.lightA
        B = self.lightB
        cA, cB = self.evaluate_requests()

        congestA = self.roadA.vehicles_stopped_beyond_e() > 0
        congestB = self.roadB.vehicles_stopped_beyond_e() > 0
        if congestA and congestB:
            print("    üì¢ REGLA 6: Congesti√≥n detectada en ambas direcciones - cambiando a rojo")
            if A.state == 'GREEN':
                A.set_state('YELLOW')
            if B.state == 'GREEN':
                B.set_state('YELLOW')
            return

        if A.requested and B.requested:
            if A.state == 'RED' and B.state == 'RED':
                if self.last_was is None:
                    chosen = random.choice(['A','B'])
                else:
                    chosen = 'A' if self.last_was == 'B' else 'B'
                print(f"    üì¢ Solicitudes simult√°neas - Round robin: elegido {chosen}")
                if chosen == 'A':
                    A.set_state('YELLOW')
                    B.set_state('RED')
                else:
                    B.set_state('YELLOW')
                    A.set_state('RED')
                self.priority = chosen
                return

        if A.state == 'GREEN' and cA == 0 and cB > 0:
            print("    üì¢ REGLA 4: A sin veh√≠culos, B con veh√≠culos - cambiando")
            A.set_state('YELLOW')
            return
        if B.state == 'GREEN' and cB == 0 and cA > 0:
            print("    üì¢ REGLA 4: B sin veh√≠culos, A con veh√≠culos - cambiando")
            B.set_state('YELLOW')
            return

        if A.requested and B.state == 'GREEN':
            if B.min_green_remaining > 0:
                print(f"    üì¢ REGLA 2: B debe permanecer verde {B.min_green_remaining} tics m√°s")
                return
            if self.roadB.vehicles_in_intersection_zone() > 0:
                print("    üì¢ REGLA 3: Veh√≠culos en zona cr√≠tica de B - esperando")
                return
            print("    üì¢ Petici√≥n A mientras B verde - cambiando")
            B.set_state('YELLOW')
            return

        if B.requested and A.state == 'GREEN':
            if A.min_green_remaining > 0:
                print(f"    üì¢ REGLA 2: A debe permanecer verde {A.min_green_remaining} tics m√°s")
                return
            if self.roadA.vehicles_in_intersection_zone() > 0:
                print("    üì¢ REGLA 3: Veh√≠culos en zona cr√≠tica de A - esperando")
                return
            print("    üì¢ Petici√≥n B mientras A verde - cambiando")
            A.set_state('YELLOW')
            return

        if A.state == 'RED' and A.requested and not (B.state in ('YELLOW','GREEN')):
            print("    üì¢ A solicitando desde rojo")
            A.set_state('YELLOW')
            return
        if B.state == 'RED' and B.requested and not (A.state in ('YELLOW','GREEN')):
            print("    üì¢ B solicitando desde rojo")
            B.set_state('YELLOW')
            return

        if A.state == 'YELLOW' and A.time_in_state >= YELLOW_TIME:
            target = A.next_state or 'RED'
            A.set_state(target)
            if target == 'GREEN':
                self.last_was = 'A'
            return
        if B.state == 'YELLOW' and B.time_in_state >= YELLOW_TIME:
            target = B.next_state or 'RED'
            B.set_state(target)
            if target == 'GREEN':
                self.last_was = 'B'
            return

        if A.state == 'RED' and B.state == 'RED':
            if cA > 0 and cB == 0:
                print("    üì¢ Solo A tiene tr√°fico")
                A.set_state('YELLOW')
                return
            if cB > 0 and cA == 0:
                print("    üì¢ Solo B tiene tr√°fico")
                B.set_state('YELLOW')
                return

    def step(self):
        self.t += 1

        self.roadA.spawn_vehicle()
        self.roadB.spawn_vehicle()

        self.apply_rules_and_transition()

        canA = (self.lightA.state == 'GREEN')
        canB = (self.lightB.state == 'GREEN')

        crossedA = self.roadA.move_vehicles_forward(canA)
        crossedB = self.roadB.move_vehicles_forward(canB)


        self.lightA.tick()
        self.lightB.tick()

        self.log.append((self.t, crossedA, crossedB))


    def run(self, ticks=MAX_TICKS, render=True):
        if render:
            self.print_header()

        for _ in range(ticks):
            self.step()
            if render:
                self.display_state()
                print()
            if SLEEP > 0:
                time.sleep(SLEEP)

        total_crossed = sum(cA + cB for (_, cA, cB) in self.log)
        total_A = sum(cA for (_, cA, cB) in self.log)
        total_B = sum(cB for (_, cA, cB) in self.log)

        print("=" * 80)
        print("üìà ESTAD√çSTICAS FINALES")
        print("=" * 80)
        print(f"üöó Total veh√≠culos que cruzaron: {total_crossed}")
        print(f"   ‚Ä¢ Por carretera A: {total_A}")
        print(f"   ‚Ä¢ Por carretera B: {total_B}")
        print(f"üìä Eficiencia: {total_crossed/ticks:.2f} veh√≠culos/tick")

if __name__ == "__main__":
    sim = Simulation()
    sim.run(ticks=MAX_TICKS, render=True)

import random
import time
import tkinter as tk
from tkinter import ttk
from collections import deque
import threading

# ---------------------------
# Par√°metros del sistema
# ---------------------------
SEED = 42
random.seed(SEED)

r = 1   # distancia m√≠nima antes del sem√°foro (bloque)
d = 4   # distancia m√°xima para detecci√≥n atr√°s del sem√°foro (bloques)
e = 2   # distancia corta m√°s all√° de la intersecci√≥n (bloques)
n = 4   # umbral de veh√≠culos a distancia d (para solicitar verde)
u = 6   # tiempo m√≠nimo en verde (tics)
YELLOW_TIME = 1  # tiempo del amarillo intermedio

IN_LENGTH = 6
OUT_LENGTH = 6
SPAWN_PROB = 0.3
MAX_TICKS = 200
SLEEP = 0.8

# Configuraci√≥n gr√°fica
CANVAS_WIDTH = 800
CANVAS_HEIGHT = 600
ROAD_WIDTH = 60
CAR_SIZE = 20
TRAFFIC_LIGHT_SIZE = 15

# ---------------------------
# Modelos (mismos que antes)
# ---------------------------

class TrafficLight:
    def __init__(self, name):
        self.name = name
        self.state = 'RED'
        self.time_in_state = 0
        self.requested = False
        self.min_green_remaining = 0
        self.next_state = None

    def set_state(self, new_state, next_state=None):
        prev = self.state
        self.state = new_state
        self.next_state = next_state
        self.time_in_state = 0

        if new_state == 'GREEN':
            self.min_green_remaining = u
            self.next_state = None
        elif new_state == 'YELLOW':
            if next_state is not None:
                self.next_state = next_state
            else:
                self.next_state = 'RED' if prev == 'GREEN' else 'GREEN'
            self.min_green_remaining = 0
        else:  # RED
            self.min_green_remaining = 0
            self.next_state = None

    def tick(self):
        self.time_in_state += 1
        if self.state == 'GREEN' and self.min_green_remaining > 0:
            self.min_green_remaining -= 1

class Road:
    def __init__(self, name):
        self.name = name
        self.approach = deque([0]*IN_LENGTH)
        self.exit_lane = deque([0]*OUT_LENGTH)

    def spawn_vehicle(self, prob=SPAWN_PROB):
        if random.random() < prob:
            if self.approach[0] == 0:
                self.approach[0] = 1

    def count_behind_red(self, distance=d):
        start = max(0, IN_LENGTH - distance)
        return sum(self.approach[i] for i in range(start, IN_LENGTH))

    def vehicle_at_r(self):
        return self.approach[IN_LENGTH-r] == 1 if IN_LENGTH-r >= 0 else False

    def vehicles_in_intersection_zone(self):
        start = max(0, IN_LENGTH - r)
        return sum(self.approach[i] for i in range(start, IN_LENGTH))

    def vehicles_stopped_beyond_e(self):
        return sum(self.exit_lane[i] for i in range(min(e, len(self.exit_lane))))

    def move_vehicles_forward(self, can_enter_intersection):
        crossed = 0
        just_crossed = False

        if self.exit_lane[-1] == 1:
            self.exit_lane[-1] = 0

        for i in range(OUT_LENGTH-2, -1, -1):
            if self.exit_lane[i] == 1:
                self.exit_lane[i+1] = 1
                self.exit_lane[i] = 0

        if self.approach[IN_LENGTH-1] == 1:
            if can_enter_intersection:
                if self.exit_lane[0] == 0:
                    self.exit_lane[0] = 1
                    self.approach[IN_LENGTH-1] = 0
                    crossed = 1
                    just_crossed = True

        for i in range(IN_LENGTH-2, -1, -1):
            if self.approach[i] == 1 and self.approach[i+1] == 0:
                self.approach[i+1] = 1
                self.approach[i] = 0

        return crossed

# ---------------------------
# Interfaz Gr√°fica
# ---------------------------

class TrafficSimulationGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("üö¶ Simulador de Sem√°foros Auto-Organizantes")
        self.root.geometry("1000x700")
        self.root.configure(bg='#2c3e50')

        # Variables de simulaci√≥n
        self.simulation = None
        self.running = False
        self.paused = False
        self.tick_count = 0

        # Crear la interfaz
        self.create_widgets()

        # Inicializar simulaci√≥n
        self.reset_simulation()

    def create_widgets(self):
        # Frame principal
        main_frame = tk.Frame(self.root, bg='#2c3e50')
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Frame superior para controles
        control_frame = tk.Frame(main_frame, bg='#34495e', relief=tk.RAISED, bd=2)
        control_frame.pack(fill=tk.X, pady=(0, 10))

        # T√≠tulo
        title_label = tk.Label(control_frame, text="üö¶ SIMULADOR DE SEM√ÅFOROS AUTO-ORGANIZANTES",
                              font=('Arial', 16, 'bold'), bg='#34495e', fg='white')
        title_label.pack(pady=10)

        # Botones de control
        button_frame = tk.Frame(control_frame, bg='#34495e')
        button_frame.pack(pady=5)

        self.start_btn = tk.Button(button_frame, text="‚ñ∂Ô∏è Iniciar", command=self.start_simulation,
                                  bg='#27ae60', fg='white', font=('Arial', 12, 'bold'))
        self.start_btn.pack(side=tk.LEFT, padx=5)

        self.pause_btn = tk.Button(button_frame, text="‚è∏Ô∏è Pausar", command=self.pause_simulation,
                                  bg='#f39c12', fg='white', font=('Arial', 12, 'bold'))
        self.pause_btn.pack(side=tk.LEFT, padx=5)

        self.reset_btn = tk.Button(button_frame, text="üîÑ Reiniciar", command=self.reset_simulation,
                                  bg='#e74c3c', fg='white', font=('Arial', 12, 'bold'))
        self.reset_btn.pack(side=tk.LEFT, padx=5)

        # Control de velocidad
        speed_frame = tk.Frame(control_frame, bg='#34495e')
        speed_frame.pack(pady=5)

        tk.Label(speed_frame, text="Velocidad:", bg='#34495e', fg='white', font=('Arial', 10)).pack(side=tk.LEFT)
        self.speed_var = tk.DoubleVar(value=0.8)
        speed_scale = tk.Scale(speed_frame, from_=0.1, to=2.0, resolution=0.1,
                              variable=self.speed_var, orient=tk.HORIZONTAL,
                              bg='#34495e', fg='white', highlightthickness=0)
        speed_scale.pack(side=tk.LEFT, padx=5)

        # Frame para canvas y estad√≠sticas
        content_frame = tk.Frame(main_frame, bg='#2c3e50')
        content_frame.pack(fill=tk.BOTH, expand=True)

        # Canvas para la simulaci√≥n
        canvas_frame = tk.Frame(content_frame, bg='#2c3e50')
        canvas_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.canvas = tk.Canvas(canvas_frame, width=CANVAS_WIDTH, height=CANVAS_HEIGHT,
                               bg='#1a252f', highlightthickness=2, highlightbackground='#34495e')
        self.canvas.pack(padx=5, pady=5)

        # Frame derecho para estad√≠sticas
        stats_frame = tk.Frame(content_frame, bg='#34495e', width=200, relief=tk.RAISED, bd=2)
        stats_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=(5, 0), pady=5)
        stats_frame.pack_propagate(False)

        # Estad√≠sticas en tiempo real
        tk.Label(stats_frame, text="üìä ESTAD√çSTICAS", font=('Arial', 14, 'bold'),
                bg='#34495e', fg='white').pack(pady=10)

        self.stats_labels = {}
        stats_info = [
            ("tick", "‚è∞ Tick:"),
            ("lightA", "üö¶ Sem√°foro A:"),
            ("lightB", "üö¶ Sem√°foro B:"),
            ("carsA", "üöó Cola A:"),
            ("carsB", "üöó Cola B:"),
            ("crossedA", "‚úÖ Cruzaron A:"),
            ("crossedB", "‚úÖ Cruzaron B:"),
            ("totalCrossed", "üèÅ Total:"),
            ("efficiency", "üìà Eficiencia:")
        ]

        for key, label in stats_info:
            frame = tk.Frame(stats_frame, bg='#34495e')
            frame.pack(fill=tk.X, padx=10, pady=2)

            tk.Label(frame, text=label, bg='#34495e', fg='#bdc3c7',
                    font=('Arial', 10), anchor='w').pack(side=tk.LEFT)

            self.stats_labels[key] = tk.Label(frame, text="0", bg='#34495e', fg='white',
                                             font=('Arial', 10, 'bold'), anchor='e')
            self.stats_labels[key].pack(side=tk.RIGHT)

        # Leyenda
        legend_frame = tk.LabelFrame(stats_frame, text="üéØ Leyenda", bg='#34495e', fg='white',
                                    font=('Arial', 12, 'bold'))
        legend_frame.pack(fill=tk.X, padx=10, pady=20)

        legend_items = [
            ("üü¶", "Carros normales"),
            ("üü•", "Zona cr√≠tica"),
            ("üü®", "Zona de salida"),
            ("üî¥", "Sem√°foro rojo"),
            ("üü°", "Sem√°foro amarillo"),
            ("üü¢", "Sem√°foro verde")
        ]

        for symbol, desc in legend_items:
            frame = tk.Frame(legend_frame, bg='#34495e')
            frame.pack(fill=tk.X, padx=5, pady=1)

            tk.Label(frame, text=symbol, bg='#34495e', fg='white',
                    font=('Arial', 10)).pack(side=tk.LEFT)
            tk.Label(frame, text=desc, bg='#34495e', fg='#bdc3c7',
                    font=('Arial', 9), anchor='w').pack(side=tk.LEFT, padx=(5, 0))

        # Par√°metros
        params_frame = tk.LabelFrame(stats_frame, text="‚öôÔ∏è Par√°metros", bg='#34495e', fg='white',
                                    font=('Arial', 12, 'bold'))
        params_frame.pack(fill=tk.X, padx=10, pady=10)

        params_text = f"r={r}, d={d}, e={e}\nn={n}, u={u}"
        tk.Label(params_frame, text=params_text, bg='#34495e', fg='#bdc3c7',
                font=('Arial', 9), justify=tk.LEFT).pack(padx=5, pady=5)

    def reset_simulation(self):
        self.running = False
        self.paused = False
        self.tick_count = 0

        # Crear nueva simulaci√≥n
        self.simulation = Simulation()

        # Actualizar estad√≠sticas
        self.update_stats()

        # Dibujar estado inicial
        self.draw_simulation()

    def start_simulation(self):
        if not self.running:
            self.running = True
            self.paused = False
            # Ejecutar simulaci√≥n en hilo separado
            thread = threading.Thread(target=self.run_simulation_thread)
            thread.daemon = True
            thread.start()

    def pause_simulation(self):
        self.paused = not self.paused

    def run_simulation_thread(self):
        while self.running and self.tick_count < MAX_TICKS:
            if not self.paused:
                # Avanzar un paso
                self.simulation.step()
                self.tick_count += 1

                # Actualizar interfaz en el hilo principal
                self.root.after(0, self.update_display)

            # Pausa basada en velocidad
            time.sleep(self.speed_var.get())

        self.running = False

    def update_display(self):
        self.draw_simulation()
        self.update_stats()

    def update_stats(self):
        if self.simulation:
            # Calcular estad√≠sticas
            total_A = sum(cA for (_, cA, cB) in self.simulation.log)
            total_B = sum(cB for (_, cA, cB) in self.simulation.log)
            total_crossed = total_A + total_B
            efficiency = total_crossed / max(1, self.tick_count)

            # Actualizar labels
            self.stats_labels["tick"].config(text=str(self.tick_count))

            # Estados de sem√°foros con colores
            light_colors = {'RED': 'üî¥', 'YELLOW': 'üü°', 'GREEN': 'üü¢'}
            stateA = light_colors.get(self.simulation.lightA.state, self.simulation.lightA.state)
            stateB = light_colors.get(self.simulation.lightB.state, self.simulation.lightB.state)

            self.stats_labels["lightA"].config(text=f"{stateA} ({self.simulation.lightA.time_in_state})")
            self.stats_labels["lightB"].config(text=f"{stateB} ({self.simulation.lightB.time_in_state})")

            self.stats_labels["carsA"].config(text=str(self.simulation.roadA.count_behind_red()))
            self.stats_labels["carsB"].config(text=str(self.simulation.roadB.count_behind_red()))
            self.stats_labels["crossedA"].config(text=str(total_A))
            self.stats_labels["crossedB"].config(text=str(total_B))
            self.stats_labels["totalCrossed"].config(text=str(total_crossed))
            self.stats_labels["efficiency"].config(text=f"{efficiency:.2f}/tick")

    def draw_simulation(self):
        self.canvas.delete("all")

        # Coordenadas centrales
        center_x = CANVAS_WIDTH // 2
        center_y = CANVAS_HEIGHT // 2

        # Dibujar intersecci√≥n
        self.draw_intersection(center_x, center_y)

        # Dibujar carreteras y veh√≠culos
        self.draw_road_horizontal(center_x, center_y, self.simulation.roadA, 'A')
        self.draw_road_vertical(center_x, center_y, self.simulation.roadB, 'B')

        # Dibujar sem√°foros
        self.draw_traffic_lights(center_x, center_y)

    def draw_intersection(self, center_x, center_y):
        # Intersecci√≥n principal
        intersection_size = ROAD_WIDTH + 20
        self.canvas.create_rectangle(
            center_x - intersection_size//2, center_y - intersection_size//2,
            center_x + intersection_size//2, center_y + intersection_size//2,
            fill='#2c3e50', outline='#34495e', width=3
        )

        # L√≠neas de carretera horizontales
        self.canvas.create_rectangle(
            0, center_y - ROAD_WIDTH//2,
            CANVAS_WIDTH, center_y + ROAD_WIDTH//2,
            fill='#34495e', outline='#7f8c8d', width=2
        )

        # L√≠neas de carretera verticales
        self.canvas.create_rectangle(
            center_x - ROAD_WIDTH//2, 0,
            center_x + ROAD_WIDTH//2, CANVAS_HEIGHT,
            fill='#34495e', outline='#7f8c8d', width=2
        )

        # L√≠neas divisorias
        self.canvas.create_line(center_x, 0, center_x, center_y - intersection_size//2,
                               fill='yellow', width=2, dash=(5, 5))
        self.canvas.create_line(center_x, center_y + intersection_size//2, center_x, CANVAS_HEIGHT,
                               fill='yellow', width=2, dash=(5, 5))
        self.canvas.create_line(0, center_y, center_x - intersection_size//2, center_y,
                               fill='yellow', width=2, dash=(5, 5))
        self.canvas.create_line(center_x + intersection_size//2, center_y, CANVAS_WIDTH, center_y,
                               fill='yellow', width=2, dash=(5, 5))

    def draw_road_horizontal(self, center_x, center_y, road, name):
        # Calcular posiciones
        lane_y = center_y - ROAD_WIDTH//4 if name == 'A' else center_y + ROAD_WIDTH//4

        # Dibujar veh√≠culos en approach (llegando desde la izquierda)
        for i, has_car in enumerate(road.approach):
            if has_car:
                x = 50 + i * 40  # Espaciado de veh√≠culos

                # Color seg√∫n zona
                if i >= IN_LENGTH - r:  # Zona cr√≠tica
                    color = '#e74c3c'  # Rojo
                elif i >= IN_LENGTH - d:  # Zona de detecci√≥n
                    color = '#f39c12'  # Naranja
                else:
                    color = '#3498db'  # Azul

                self.draw_car(x, lane_y, color, '‚Üí')

        # Dibujar veh√≠culos en exit_lane (saliendo hacia la derecha)
        for i, has_car in enumerate(road.exit_lane):
            if has_car:
                x = center_x + 50 + i * 40

                # Color seg√∫n zona
                if i < e:  # Zona de salida
                    color = '#f1c40f'  # Amarillo
                else:
                    color = '#3498db'  # Azul

                self.draw_car(x, lane_y, color, '‚Üí')

    def draw_road_vertical(self, center_x, center_y, road, name):
        # Calcular posiciones
        lane_x = center_x - ROAD_WIDTH//4 if name == 'B' else center_x + ROAD_WIDTH//4

        # Dibujar veh√≠culos en approach (llegando desde arriba)
        for i, has_car in enumerate(road.approach):
            if has_car:
                y = 50 + i * 40

                # Color seg√∫n zona
                if i >= IN_LENGTH - r:  # Zona cr√≠tica
                    color = '#e74c3c'  # Rojo
                elif i >= IN_LENGTH - d:  # Zona de detecci√≥n
                    color = '#f39c12'  # Naranja
                else:
                    color = '#3498db'  # Azul

                self.draw_car(lane_x, y, color, '‚Üì')

        # Dibujar veh√≠culos en exit_lane (saliendo hacia abajo)
        for i, has_car in enumerate(road.exit_lane):
            if has_car:
                y = center_y + 50 + i * 40

                # Color seg√∫n zona
                if i < e:  # Zona de salida
                    color = '#f1c40f'  # Amarillo
                else:
                    color = '#3498db'  # Azul

                self.draw_car(lane_x, y, color, '‚Üì')

    def draw_car(self, x, y, color, direction):
        # Dibujar rect√°ngulo del carro
        self.canvas.create_rectangle(
            x - CAR_SIZE//2, y - CAR_SIZE//3,
            x + CAR_SIZE//2, y + CAR_SIZE//3,
            fill=color, outline='white', width=1
        )

        # Dibujar direcci√≥n
        self.canvas.create_text(x, y, text=direction, fill='white', font=('Arial', 8, 'bold'))


    def draw_traffic_lights(self, center_x, center_y):
        # Posiciones de los sem√°foros (A = izquierda, B = arriba)
        lights_pos = {
            'A': (center_x - 100, center_y - 40),  # Izquierda (m√°s a la izquierda)
            'B': (center_x - 40, center_y - 120)   # Arriba (m√°s arriba)
        }

        # Colores "apagados" (hex v√°lidos) y colores cuando est√°n activos
        off_colors = ['#4d0000', '#665500', '#003300']   # rojo apagado, amarillo apagado, verde apagado
        active_colors = {'RED': 'red', 'YELLOW': 'yellow', 'GREEN': 'green'}
        states = ['RED', 'YELLOW', 'GREEN']

        for light_name, (x, y) in lights_pos.items():
            light = getattr(self.simulation, f'light{light_name}')

            # Fondo del sem√°foro (caja)
            self.canvas.create_rectangle(
                x - 18, y - 28, x + 18, y + 28,
                fill='black', outline='gray', width=2
            )

            # Dibujar 3 leds (siempre dibujados; se selecciona color on/off)
            for i, state in enumerate(states):
                light_y = y - 14 + i * 18
                # color final: activo si coincide el estado, si no el color "apagado"
                final_color = active_colors[state] if light.state == state else off_colors[i]

                self.canvas.create_oval(
                    x - 10, light_y - 6, x + 10, light_y + 6,
                    fill=final_color, outline='white', width=1
                )

            # Etiqueta del sem√°foro
            self.canvas.create_text(x, y + 40, text=f'Sem√°foro {light_name}',
                                    fill='white', font=('Arial', 10, 'bold'))


# ---------------------------
# Simulaci√≥n (misma l√≥gica)
# ---------------------------

class Simulation:
    def __init__(self):
        self.lightA = TrafficLight('A')
        self.lightB = TrafficLight('B')
        self.lightA.set_state('RED')
        self.lightB.set_state('RED')
        self.roadA = Road('A')
        self.roadB = Road('B')
        self.t = 0
        self.priority = None
        self.last_was = None
        self.log = []

    def evaluate_requests(self):
        cA = self.roadA.count_behind_red()
        cB = self.roadB.count_behind_red()
        self.lightA.requested = (cA >= n)
        self.lightB.requested = (cB >= n)
        return cA, cB

    def apply_rules_and_transition(self):
        A = self.lightA
        B = self.lightB
        cA, cB = self.evaluate_requests()

        congestA = self.roadA.vehicles_stopped_beyond_e() > 0
        congestB = self.roadB.vehicles_stopped_beyond_e() > 0
        if congestA and congestB:
            if A.state == 'GREEN':
                A.set_state('YELLOW')
            if B.state == 'GREEN':
                B.set_state('YELLOW')
            return

        if A.requested and B.requested:
            if A.state == 'RED' and B.state == 'RED':
                if self.last_was is None:
                    chosen = random.choice(['A','B'])
                else:
                    chosen = 'A' if self.last_was == 'B' else 'B'
                if chosen == 'A':
                    A.set_state('YELLOW')
                    B.set_state('RED')
                else:
                    B.set_state('YELLOW')
                    A.set_state('RED')
                self.priority = chosen
                return

        if A.state == 'GREEN' and cA == 0 and cB > 0:
            A.set_state('YELLOW')
            return
        if B.state == 'GREEN' and cB == 0 and cA > 0:
            B.set_state('YELLOW')
            return

        if A.requested and B.state == 'GREEN':
            if B.min_green_remaining > 0:
                return
            if self.roadB.vehicles_in_intersection_zone() > 0:
                return
            B.set_state('YELLOW')
            return

        if B.requested and A.state == 'GREEN':
            if A.min_green_remaining > 0:
                return
            if self.roadA.vehicles_in_intersection_zone() > 0:
                return
            A.set_state('YELLOW')
            return

        if A.state == 'RED' and A.requested and not (B.state in ('YELLOW','GREEN')):
            A.set_state('YELLOW')
            return
        if B.state == 'RED' and B.requested and not (A.state in ('YELLOW','GREEN')):
            B.set_state('YELLOW')
            return

        if A.state == 'YELLOW' and A.time_in_state >= YELLOW_TIME:
            target = A.next_state or 'RED'
            A.set_state(target)
            if target == 'GREEN':
                self.last_was = 'A'
            return
        if B.state == 'YELLOW' and B.time_in_state >= YELLOW_TIME:
            target = B.next_state or 'RED'
            B.set_state(target)
            if target == 'GREEN':
                self.last_was = 'B'
            return

        if A.state == 'RED' and B.state == 'RED':
            if cA > 0 and cB == 0:
                A.set_state('YELLOW')
                return
            if cB > 0 and cA == 0:
                B.set_state('YELLOW')
                return

    def step(self):
        self.t += 1

        self.roadA.spawn_vehicle()
        self.roadB.spawn_vehicle()

        self.apply_rules_and_transition()

        canA = (self.lightA.state == 'GREEN')
        canB = (self.lightB.state == 'GREEN')

        crossedA = self.roadA.move_vehicles_forward(canA)
        crossedB = self.roadB.move_vehicles_forward(canB)

        self.lightA.tick()
        self.lightB.tick()

        self.log.append((self.t, crossedA, crossedB))

# ---------------------------
# Ejecuci√≥n principal
# ---------------------------

if __name__ == "__main__":
    root = tk.Tk()
    app = TrafficSimulationGUI(root)
    root.mainloop()


    '''
    Toca tomar datos para hcaer la comparacion?
    Se vale solo 2 semaforos?
    '''